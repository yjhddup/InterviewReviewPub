### 内存区域和内存溢出异常

#### 运行时数据区域

##### 程序计数器

当前线程所执行的字节码的行号指示器，通过改变计数器的值来选取下一条需要执行的字节码指令。

每条线程都有独立的程序计数器，是**线程私有**的内存。 

##### 虚拟机栈

线程私有，生命周期和线程同步。java方法执行的内存模型，每个方法对应一个**栈帧**，栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。方法的调用与结束对应一个栈帧的入栈与出栈。

局部变量表：存放编译器可知的各种java虚拟机基本数据类型、对象引用和returnAddress类型（指向一条字节码的地址）。其中基本数据类型以局部变量槽（slot）来表示在局部变量表当中的存储空间，long和double（64位）占用两个变量槽，其余的数据只占用一个。变量表所需的**内存空间**在**编译期间完成分配**。

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出stackoverflowError异常；如果虚拟机栈容量可以动态扩展，当栈扩展无法申请到足够的内存会抛出OutOfMemoryError异常。

##### 本地方法栈

与虚拟机栈的作用相似，只不过服务于虚拟机使用到的本地（native）方法。和虚拟机栈一样，本地方法栈在栈深度溢出或者动态扩展失败是会分别抛出stackoverflowError和OutOfMemoryError异常

##### Java堆

被所有**线程共享**的一块内存区域，在**虚拟机启动时创建**。此内存区域的唯一目的就是**存放对象实例**，同时也是垃圾回收器管理的内存区域。当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms来设定）。如果在Java堆当中没有内存完成实力分配，并且堆也无法扩展时，Java虚拟机将会抛出OutOfMemoryEoor异常

##### 方法区

**各个线程共享**的内存区域,用于存储已被虚拟机加载的[类型信息](比如类名，变量，方法签名)、常量、静态变量、即时编译器编译后的代码缓存等数据。如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

###### 运行时常量池

方法区的一部分。用于存放Class文件当中除了类的版本、字段、方法、接口等描述信息外的**常量池表**，

常量池表主要用于存放编译器生成的各种[字面量](描述自己的量比如"abc"描述了自己)和符号引用。

String的intern()：将new出来的字符串放入运行时常量池

在无法申请到内存是会抛出OutOfMemoryError异常

##### 直接内存

不是虚拟机运行时数据区的一部分，同时也不是《Java虚拟机规范》中定义的内存区域。但是也可能导致OutOfMemoryError异常。

#### 对象

##### 普通对象的创建

当遇到new时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化。

类加载检查通过后，虚拟机为对象分配内存。内存分配方式：指针碰撞或空闲列表。

并发情况下不是线程安全的，两种方案：**CAS配上失败重试**的方式保证更新操作的原子性（实际使用）：另一种把内存分配的动作按照线程放在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为**本地缓冲（TLAB）**，哪个线程要分配内存就在哪个线程的本地缓冲区中分配，如果本地缓冲区用完了，分配最新的缓冲区时需要同步锁定。是否使用TLAB，可以通过**-XX：+/-UseTLAB**参数来设定

 内存分配完成之后，将分配到的除对象头之外的内存空间都初始化零值。此时完成new

new完成之后会接着执行<init>()方法

##### 对象的内存布局

对象的存储布局可以划分为三个部分：对象头、实例数据和对其填充。

对象头包括：**第一类**用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。官方称为"Mark Word"，是一个动态定义的数据结构。**另一部分**是**类型指针**，即对象指向它的类型元数据的指针，虚拟机通过这个指针来确定该对象是哪个类的实例。

实例数据：程序代码里面所定义的各种类型的字段内容

对其填充：占位符，无特别含义

#### 对象的访问定位

java程序通过栈上的reference是数据来操作堆上的具体对象。reference是一个指向对象的具体引用，对象的访问方式主要有句柄和直接指针：

- 句柄：Java堆中划分出一块内存来作为句柄池，reference当中存储的就是对象的句柄地址，句柄当中则包含了对象实例数据各自具体的地址信息。好处：对象被移动的时候只会改变句柄中的实例数据指针
- 直接指针访问：reference中存储的直接就是对象地址。好处：速度更快

### 垃圾收集器与内存分配策略

#### 对象是否已死 

##### 引用计数法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器加一；当引用失效时，计数器就减一；计数器为零的对象就是不可能再被使用的。无法解决ABA问题

##### 可达性分析

通过一系列“GCroots”的根对象作为起始节点，从这节点开始根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果某个对象到GC roots间没有任何引用链相连，则证明此对象是不可能再被使用的。

可作为GCRoots的对象包括：

- 虚拟机栈中（栈帧中的本地变量表）引用的对象，参数、局部变量表、临时变量等
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中引用的对象
- 虚拟机内部的引用，基本类型对应的Class对象，常驻的异常对象等
- 同步锁 持有的对象

##### 引用

强引用、软引用、弱引用和虚引用：

+ 强引用指在程序都是代码之中普遍存在的引用赋值。只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象
+ 软引用是用来描述一些还有用，但是非必须的对象。只被软引用关联的对象，在系统将要的发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。如果回收后还没有足够的内存，才会抛出内存溢出异常。SoftReference类实现
+ 弱引用也是描述那些非必须对象。 弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前1内存是否足够，都会回收掉只被弱引用关联的对象。WeakReference类来实现
+ 虚引用，虚引用的存在无法影响对象的生存时间，也不能通过虚引用来获取对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。PhantomReference实现





